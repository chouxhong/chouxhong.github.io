<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PPT æ™ºèƒ½æ‰¹é‡å¡«å­—å·¥å…·</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        body { font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif; background-color: #f9fafb; }
        .loading-overlay {
            background: rgba(255, 255, 255, 0.95);
            z-index: 100;
        }
        canvas { border: 1px solid #e5e7eb; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); }
        /* Custom scrollbar for desktop */
        @media (min-width: 1024px) {
            ::-webkit-scrollbar { width: 8px; height: 8px; }
            ::-webkit-scrollbar-track { background: #f1f1f1; }
            ::-webkit-scrollbar-thumb { background: #c1c1c1; border-radius: 4px; }
            ::-webkit-scrollbar-thumb:hover { background: #a8a8a8; }
        }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden text-gray-800">

    <!-- Header -->
    <header class="bg-white shadow-sm z-30 px-4 py-3 flex-none">
        <div class="max-w-7xl mx-auto flex justify-between items-center">
            <h1 class="text-lg md:text-xl font-bold text-gray-800 flex items-center gap-2 truncate">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-blue-600 flex-shrink-0" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 12l3-3 3 3 4-4M8 21l4-4 4 4M3 4h18M4 4h16v12a1 1 0 01-1 1H5a1 1 0 01-1-1V4z" />
                </svg>
                <span class="truncate">PPT æ™ºèƒ½æ‰¹é‡å¡«å­—</span>
            </h1>
            <button onclick="resetApp()" class="text-xs md:text-sm text-red-500 hover:text-red-700 whitespace-nowrap ml-4">é‡ç½®/æ¸…ç©º</button>
        </div>
    </header>

    <!-- Main Content -->
    <!-- Mobile: Overflow-y-auto (scroll whole page), Desktop: Overflow-hidden (split panes scroll independently) -->
    <main class="flex-1 flex flex-col lg:flex-row overflow-y-auto lg:overflow-hidden relative bg-gray-50">
        
        <!-- Sidebar: Controls -->
        <!-- Mobile: w-full, auto height. Desktop: w-1/3, full height, scrollable -->
        <div class="w-full lg:w-1/3 lg:min-w-[360px] bg-white border-b lg:border-b-0 lg:border-r border-gray-200 flex flex-col p-4 md:p-6 gap-5 shadow-sm z-20 flex-shrink-0 lg:h-full lg:overflow-y-auto">
            
            <!-- Step 1: PPT Template -->
            <div class="space-y-3">
                <div class="flex items-center justify-between">
                    <h2 class="text-base md:text-lg font-semibold text-gray-700 flex items-center gap-2">
                        <span class="bg-blue-100 text-blue-800 text-xs font-bold px-2 py-0.5 rounded-full">1</span>
                        PPT æ¨¡æ¿
                    </h2>
                    <span id="pptStatus" class="text-xs px-2 py-1 rounded bg-gray-100 text-gray-500">æœªå°±ç»ª</span>
                </div>
                
                <div id="pptUploadArea" class="border-2 border-dashed border-blue-200 rounded-lg p-6 text-center hover:bg-blue-50 transition cursor-pointer relative bg-blue-50/30">
                    <input type="file" id="pptInput" accept=".pptx" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer">
                    <div class="text-blue-500 mb-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                        </svg>
                    </div>
                    <p class="text-sm text-gray-600 font-medium">ç‚¹å‡»ä¸Šä¼  .pptx</p>
                    <p class="text-xs text-gray-400 mt-1">éœ€å«â€œè¥æœåç§°â€æ–‡æœ¬æ¡†</p>
                </div>
                
                <!-- Parsed Info Display -->
                <div id="pptInfo" class="hidden text-sm bg-green-50 p-3 rounded border border-green-100 text-green-800 flex justify-between items-center">
                    <span>âœ… æ¨¡æ¿å·²åŠ è½½</span>
                    <button onclick="document.getElementById('pptInput').click()" class="text-xs text-green-600 underline">é‡æ–°ä¸Šä¼ </button>
                </div>
            </div>

            <!-- Step 2: OCR Image -->
            <div class="space-y-3">
                <h2 class="text-base md:text-lg font-semibold text-gray-700 flex items-center gap-2">
                    <span class="bg-indigo-100 text-indigo-800 text-xs font-bold px-2 py-0.5 rounded-full">2</span>
                    åå•è¯†åˆ«
                </h2>
                <div class="border-2 border-dashed border-indigo-200 rounded-lg p-4 md:p-6 text-center hover:bg-indigo-50 transition cursor-pointer relative bg-indigo-50/30">
                    <input type="file" id="ocrInput" accept="image/*" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer">
                    <div class="text-indigo-500 mb-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z" />
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 13a3 3 0 11-6 0 3 3 0 016 0z" />
                        </svg>
                    </div>
                    <p class="text-sm text-gray-600 font-medium">æ‹ç…§/ä¸Šä¼ åå•å›¾ç‰‡</p>
                </div>
                
                <!-- OCR Result Text Area -->
                <div>
                    <div class="flex justify-between items-center mb-1">
                        <label class="text-xs text-gray-500">åå•åˆ—è¡¨ (å·²è‡ªåŠ¨ä¼˜åŒ–):</label>
                        <span id="lineCount" class="text-xs text-blue-600 font-bold bg-blue-50 px-2 py-0.5 rounded">0 è¡Œ</span>
                    </div>
                    <textarea id="textList" class="w-full h-28 p-3 border border-gray-300 rounded-lg text-sm focus:ring-2 focus:ring-blue-500 focus:outline-none resize-none shadow-inner" placeholder="è¯†åˆ«ç»“æœå°†æ˜¾ç¤ºåœ¨è¿™é‡Œ..."></textarea>
                </div>
            </div>

            <!-- Step 3: Action -->
            <button id="generateBtn" disabled class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3.5 rounded-xl shadow-lg transition active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed disabled:active:scale-100 mb-4 lg:mb-0">
                ğŸš€ å¼€å§‹æ‰¹é‡ç”Ÿæˆ & å¯¼å‡º
            </button>
        </div>

        <!-- Right Side: Preview & Results -->
        <!-- Mobile: w-full, auto height. Desktop: flex-1, full height, scrollable -->
        <div class="w-full lg:flex-1 bg-gray-50 p-4 md:p-8 flex flex-col items-center lg:h-full lg:overflow-y-auto">
            
            <!-- Canvas Container -->
            <div class="w-full max-w-2xl mb-8">
                <h3 class="text-center text-gray-400 mb-2 text-xs uppercase tracking-widest font-semibold">å®æ—¶é¢„è§ˆ</h3>
                
                <!-- Wrapper for responsive scaling -->
                <div id="canvasWrapper" class="w-full relative flex justify-center bg-transparent">
                    <div class="canvas-container shadow-2xl border-[3px] border-white rounded-lg overflow-hidden bg-white">
                        <canvas id="previewCanvas"></canvas>
                    </div>
                </div>
            </div>

            <!-- Results Section -->
            <div id="resultsArea" class="w-full max-w-5xl hidden flex flex-col gap-8 pb-10">
                
                <!-- 1. Images Grid -->
                <div class="bg-white p-4 md:p-6 rounded-xl shadow-sm border border-gray-200">
                    <div class="flex justify-between items-center border-b border-gray-100 pb-3 mb-4">
                        <h3 class="text-base md:text-lg font-bold text-gray-800 flex items-center gap-2">
                            ğŸ–¼ï¸ å›¾ç‰‡ç»“æœ
                        </h3>
                        <button onclick="downloadAll()" class="text-xs md:text-sm bg-green-600 text-white px-3 py-1.5 rounded-lg hover:bg-green-700 transition flex items-center gap-1 shadow-sm">
                            <span>ğŸ“¥ ä¸‹è½½å…¨éƒ¨(ZIP)</span>
                        </button>
                    </div>
                    <div id="gallery" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-3 md:gap-4">
                        <!-- Images will be injected here -->
                    </div>
                </div>

                <!-- 2. Blessing Text -->
                <div class="bg-white p-4 md:p-6 rounded-xl shadow-sm border border-gray-200">
                    <div class="flex justify-between items-center border-b border-gray-100 pb-3 mb-4">
                        <h3 class="text-base md:text-lg font-bold text-gray-800 flex items-center gap-2">
                            ğŸ“ ç¥ç¦è¯­
                        </h3>
                        <button onclick="copyBlessingText()" class="text-xs md:text-sm bg-indigo-600 text-white px-3 py-1.5 rounded-lg hover:bg-indigo-700 transition flex items-center gap-1 shadow-sm">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3" />
                            </svg>
                            <span>å¤åˆ¶å…¨éƒ¨</span>
                        </button>
                    </div>
                    <textarea id="blessingText" class="w-full h-40 p-3 border border-gray-200 rounded-lg bg-gray-50 text-gray-600 text-sm focus:outline-none" readonly></textarea>
                </div>
            </div>
        </div>
    </main>

    <!-- Footer -->
    <footer class="bg-gray-50 border-t border-gray-200 py-3 text-center text-xs text-gray-400 flex-none z-30">
        åˆ¶ä½œï¼šby xhong &nbsp;&nbsp; è”ç³»é‚®ç®±ï¼šzhouxhong@qq.com
    </footer>

    <!-- Global Loader -->
    <div id="loader" class="fixed inset-0 loading-overlay flex flex-col items-center justify-center hidden">
        <div class="animate-spin rounded-full h-10 w-10 md:h-12 md:w-12 border-4 border-gray-200 border-t-blue-600 mb-4"></div>
        <p id="loaderText" class="text-gray-700 font-medium text-sm md:text-base">æ­£åœ¨å¤„ç†...</p>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/localforage/1.10.0/localforage.min.js"></script>

    <script>
        // --- Constants & State ---
        const TARGET_TEXT = "è¥æœåç§°";
        
        let fabricCanvas = null;
        let pptData = {
            bgImage: null, // Base64 string
            width: 1280,
            height: 720,
            textBox: null // { x, y, width, height, fontSize, fontFamily, color }
        };
        let generatedImages = []; 

        // --- Initialization ---
        window.onload = async () => {
            if (typeof fabric === 'undefined') {
                alert("ç»„ä»¶åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢ã€‚");
                return;
            }
            
            initCanvas();
            await checkStoredPPT();
            setupEventListeners();
            
            // Initial layout adjustment
            adjustPreviewScale();
            // Listen for window resize to adjust canvas scale
            window.addEventListener('resize', () => {
                requestAnimationFrame(adjustPreviewScale);
            });
        };

        function initCanvas() {
            try {
                // Initialize canvas but dimensions will be set by pptData later
                fabricCanvas = new fabric.Canvas('previewCanvas', {
                    enableRetinaScaling: true,
                    selection: false
                });
            } catch (error) {
                console.error("Canvas Init Error:", error);
            }
        }

        // --- Adaptive Scaling Logic ---
        function adjustPreviewScale() {
            if (!pptData.bgImage) return;

            const container = document.getElementById('canvasWrapper');
            const canvasContainerEl = document.querySelector('.canvas-container');
            if (!container || !canvasContainerEl) return;

            // The desired width is the container width (minus padding automatically handled by parent flex)
            const availableWidth = container.clientWidth;
            
            // Calculate scale ratio based on PPT original width vs available screen width
            // We limit max scale to 1 (don't upscale pixelatedly on huge screens if PPT is small, though usually PPT is HD)
            // But usually we just shrink to fit.
            let scale = availableWidth / pptData.width;
            
            // On very wide screens, don't let it get ridiculously huge, maybe cap width
            if (scale > 1) scale = 1; 

            // Apply Transform
            canvasContainerEl.style.transformOrigin = 'top left';
            canvasContainerEl.style.transform = `scale(${scale})`;
            
            // Adjust the wrapper height because 'transform' doesn't affect flow layout height
            container.style.height = `${pptData.height * scale}px`;
        }

        function showLoader(show, text = "å¤„ç†ä¸­...") {
            const el = document.getElementById('loader');
            const txt = document.getElementById('loaderText');
            if (show) {
                txt.innerText = text;
                el.classList.remove('hidden');
            } else {
                el.classList.add('hidden');
            }
        }

        // --- Storage Logic ---
        async function checkStoredPPT() {
            try {
                const stored = await localforage.getItem('pptTemplateData');
                if (stored) {
                    pptData = stored;
                    updatePPTStatus(true, "å·²æ¢å¤ä¸Šæ¬¡æ¨¡æ¿");
                    renderPreview(TARGET_TEXT); 
                }
            } catch (e) { console.error(e); }
        }

        async function savePPTData() {
            await localforage.setItem('pptTemplateData', pptData);
        }

        async function resetApp() {
            if(confirm("ç¡®å®šè¦æ¸…é™¤å­˜å‚¨çš„æ¨¡æ¿å’Œæ•°æ®å—ï¼Ÿ")){
                await localforage.clear();
                location.reload();
            }
        }

        // --- Event Listeners ---
        function setupEventListeners() {
            document.getElementById('pptInput').addEventListener('change', handlePPTUpload);
            document.getElementById('ocrInput').addEventListener('change', handleOCRUpload);
            document.getElementById('textList').addEventListener('input', updateLineCount);
            document.getElementById('generateBtn').addEventListener('click', startBatchGeneration);
        }

        function updatePPTStatus(isReady, msg) {
            const statusEl = document.getElementById('pptStatus');
            const infoEl = document.getElementById('pptInfo');
            const btn = document.getElementById('generateBtn');

            if (isReady) {
                statusEl.innerText = "å·²å°±ç»ª";
                statusEl.className = "text-xs px-2 py-1 rounded bg-green-100 text-green-700";
                infoEl.classList.remove('hidden');
                document.getElementById('pptUploadArea').classList.add('hidden');
                
                if (pptData.textBox) btn.disabled = false;
            } else {
                statusEl.innerText = msg || "é”™è¯¯";
                statusEl.className = "text-xs px-2 py-1 rounded bg-red-100 text-red-700";
            }
        }

        // --- PPT Parsing Logic ---
        async function handlePPTUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            showLoader(true, "æ­£åœ¨è§£æ PPT...");

            try {
                const zip = await JSZip.loadAsync(file);
                
                let slideXmlStr = "";
                try {
                    slideXmlStr = await zip.file("ppt/slides/slide1.xml").async("string");
                } catch(e) {
                     throw new Error("æ— æ³•è¯»å–å¹»ç¯ç‰‡ï¼Œè¯·ç¡®ä¿æ˜¯æœ‰æ•ˆçš„ PPTX æ–‡ä»¶ã€‚");
                }

                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(slideXmlStr, "text/xml");
                
                // --- Robust Text Finding ---
                const allElements = xmlDoc.getElementsByTagName("*");
                let targetShape = null;
                let debugFoundTexts = [];

                for (let i = 0; i < allElements.length; i++) {
                    const el = allElements[i];
                    
                    if (el.localName === "p" && (el.prefix === "a" || el.namespaceURI?.includes("drawingml"))) {
                        const runTexts = [];
                        const textNodes = el.getElementsByTagName("*");
                        for(let k=0; k<textNodes.length; k++) {
                            if(textNodes[k].localName === "t") {
                                runTexts.push(textNodes[k].textContent);
                            }
                        }
                        const fullText = runTexts.length > 0 ? runTexts.join("") : el.textContent;
                        const normalizedText = fullText.replace(/\s+/g, "");
                        
                        if (normalizedText && debugFoundTexts.length < 5) debugFoundTexts.push(normalizedText);

                        if (normalizedText.includes(TARGET_TEXT)) {
                            let node = el;
                            while (node && node.parentNode) {
                                if (node.localName === "sp" && (node.prefix === "p" || node.namespaceURI?.includes("presentationml"))) {
                                    targetShape = node;
                                    break;
                                }
                                node = node.parentNode;
                            }
                            if (targetShape) break;
                        }
                    }
                }

                if (!targetShape) {
                     throw new Error(`é¦–é¡µæœªæ‰¾åˆ°â€œ${TARGET_TEXT}â€ã€‚å·²è¯†åˆ«åˆ°: ${debugFoundTexts.join(", ")}`);
                }

                // Extract Geometry
                const getChild = (parent, localName) => {
                    if(!parent) return null;
                    for(let i=0; i<parent.children.length; i++) {
                        if(parent.children[i].localName === localName) return parent.children[i];
                    }
                    return null;
                };

                const spPr = getChild(targetShape, "spPr");
                const xfrm = getChild(spPr, "xfrm");
                const off = getChild(xfrm, "off");
                const ext = getChild(xfrm, "ext");

                if (!off || !ext) throw new Error("æ— æ³•è¯»å–æ–‡æœ¬æ¡†åæ ‡ã€‚");

                const emuX = parseInt(off.getAttribute("x"));
                const emuY = parseInt(off.getAttribute("y"));
                const emuW = parseInt(ext.getAttribute("cx"));
                const emuH = parseInt(ext.getAttribute("cy"));

                // Slide Dimensions
                const presentationXml = await zip.file("ppt/presentation.xml").async("string");
                const presDoc = parser.parseFromString(presentationXml, "text/xml");
                const sldSzTags = presDoc.getElementsByTagName("*");
                let sldSz = null;
                for(let i=0; i<sldSzTags.length; i++){
                    if(sldSzTags[i].localName === "sldSz") { sldSz = sldSzTags[i]; break; }
                }

                const slideWidthEmu = parseInt(sldSz.getAttribute("cx"));
                const slideHeightEmu = parseInt(sldSz.getAttribute("cy"));

                const scaleFactor = 96 / 914400; 
                const canvasW = slideWidthEmu * scaleFactor;
                const canvasH = slideHeightEmu * scaleFactor;

                // Font Style
                let fontSize = 18;
                let color = "#000000";
                
                try {
                    const textBody = getChild(targetShape, "txBody");
                    const p = getChild(textBody, "p");
                    const runs = p.getElementsByTagName("*");
                    for(let i=0; i<runs.length; i++) {
                        if(runs[i].localName === "rPr") {
                            const sz = runs[i].getAttribute("sz");
                            if(sz) fontSize = parseInt(sz) / 100;
                            const solidFill = getChild(runs[i], "solidFill");
                            if(solidFill) {
                                const srgbClr = getChild(solidFill, "srgbClr");
                                if(srgbClr) color = "#" + srgbClr.getAttribute("val");
                            }
                            if(sz) break; 
                        }
                    }
                } catch(err) { console.log("Font extraction info:", err); }

                // Background
                let bgBase64 = null;
                const mediaFolder = zip.folder("ppt/media");
                let maxUserInfo = { name: "", size: 0 };
                
                if (mediaFolder) {
                    mediaFolder.forEach((relativePath, file) => {
                        if (relativePath.match(/\.(jpeg|jpg|png)$/i)) {
                            if (file._data.uncompressedSize > maxUserInfo.size) {
                                maxUserInfo = { name: relativePath, size: file._data.uncompressedSize };
                            }
                        }
                    });
                    if (maxUserInfo.name) {
                        bgBase64 = await mediaFolder.file(maxUserInfo.name).async("base64");
                        const ext = maxUserInfo.name.split('.').pop();
                        bgBase64 = `data:image/${ext};base64,${bgBase64}`;
                    }
                }

                if (!bgBase64) {
                     try {
                        const thumb = await zip.file("docProps/thumbnail.jpeg").async("base64");
                        bgBase64 = "data:image/jpeg;base64," + thumb;
                     } catch(e) { throw new Error("æ— æ³•æå–èƒŒæ™¯å›¾ã€‚"); }
                }

                pptData = {
                    width: canvasW,
                    height: canvasH,
                    bgImage: bgBase64,
                    textBox: {
                        x: emuX * scaleFactor,
                        y: emuY * scaleFactor,
                        w: emuW * scaleFactor,
                        h: emuH * scaleFactor,
                        fontSize: fontSize * 1.33,
                        color: color
                    }
                };

                await savePPTData();
                updatePPTStatus(true);
                renderPreview(TARGET_TEXT);

            } catch (err) {
                console.error(err);
                alert("è§£æå¤±è´¥: " + err.message);
                updatePPTStatus(false, "è§£æå¤±è´¥");
            } finally {
                showLoader(false);
            }
        }

        // --- Rendering Logic ---
        function renderPreview(text) {
            if (!pptData.bgImage) return;

            // Set real dimensions
            fabricCanvas.setWidth(pptData.width);
            fabricCanvas.setHeight(pptData.height);
            
            // Set Background
            fabric.Image.fromURL(pptData.bgImage, (img) => {
                img.scaleToWidth(pptData.width);
                img.scaleToHeight(pptData.height);
                fabricCanvas.setBackgroundImage(img, fabricCanvas.renderAll.bind(fabricCanvas));
                
                fabricCanvas.clear();
                fabricCanvas.setBackgroundImage(img, fabricCanvas.renderAll.bind(fabricCanvas));

                const tb = pptData.textBox;
                const textObj = new fabric.Textbox(text, {
                    left: tb.x,
                    top: tb.y,
                    width: tb.w,
                    height: tb.h, 
                    fontSize: tb.fontSize,
                    fill: tb.color,
                    fontFamily: 'SimHei, STHeiti, sans-serif',
                    textAlign: 'center',
                    originX: 'left',
                    originY: 'top',
                    editable: false
                });
                
                fabricCanvas.add(textObj);
                fabricCanvas.renderAll();
                
                // Trigger responsive scaling after render
                adjustPreviewScale();
            });
        }

        // --- OCR Logic ---
        async function handleOCRUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            showLoader(true, "æ­£åœ¨è¯†åˆ«åå•...");

            try {
                const worker = await Tesseract.createWorker('chi_sim'); 
                const ret = await worker.recognize(file);
                const text = ret.data.text;
                
                // Clean Text: Remove whitespace and append "è¥æœ"
                const lines = text.split('\n')
                                  .map(l => l.replace(/\s+/g, '').trim()) 
                                  .filter(l => l.length > 0)
                                  .map(l => l + "è¥æœ"); 
                
                document.getElementById('textList').value = lines.join('\n');
                updateLineCount();
                
                await worker.terminate();

                if (lines.length > 0) renderPreview(lines[0]);

            } catch (err) {
                alert("OCR è¯†åˆ«å¤±è´¥: " + err.message);
            } finally {
                showLoader(false);
            }
        }

        function updateLineCount() {
            const txt = document.getElementById('textList').value;
            const count = txt.split('\n').filter(l => l.trim()).length;
            document.getElementById('lineCount').innerText = `${count} è¡Œ`;
            
            const btn = document.getElementById('generateBtn');
            btn.disabled = count === 0 || !pptData.bgImage;
        }

        // --- Batch Generation ---
        async function startBatchGeneration() {
            const txt = document.getElementById('textList').value;
            const lines = txt.split('\n').filter(l => l.trim());
            
            if (lines.length === 0) return;
            
            showLoader(true, "æ­£åœ¨ç”Ÿæˆé«˜æ¸…å›¾ç‰‡...");
            generatedImages = [];
            const gallery = document.getElementById('gallery');
            gallery.innerHTML = '';
            document.getElementById('resultsArea').classList.remove('hidden');
            
            // Show Blessing Text
            const blessingTextEl = document.getElementById('blessingText');
            const blessingLines = lines.map(line => `æ­å–œ${line}å½“æ—¥é«˜å¥—å°é—­[åº†ç¥][åº†ç¥][åº†ç¥]`);
            blessingTextEl.value = blessingLines.join('\n');

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                const objs = fabricCanvas.getObjects();
                if (objs.length > 0 && objs[0].type === 'textbox') {
                    objs[0].set('text', line);
                    fabricCanvas.renderAll();
                } else {
                    renderPreview(line);
                }

                await new Promise(r => setTimeout(r, 50)); // Small delay for rendering

                // Export at 3x resolution for clarity
                const dataUrl = fabricCanvas.toDataURL({
                    format: 'png',
                    quality: 1,
                    multiplier: 3 
                });

                generatedImages.push({ name: `${line}.png`, data: dataUrl });

                const imgCard = document.createElement('div');
                imgCard.className = "group relative aspect-video bg-gray-100 rounded-lg overflow-hidden border cursor-pointer";
                imgCard.innerHTML = `
                    <img src="${dataUrl}" class="w-full h-full object-cover">
                    <div class="absolute inset-0 bg-black/50 opacity-0 group-hover:opacity-100 transition flex items-center justify-center text-white text-xs font-bold p-2 text-center">
                        ${line}
                    </div>
                `;
                gallery.appendChild(imgCard);
            }

            showLoader(false);
            
            // Scroll to results on mobile
            if (window.innerWidth < 1024) {
                document.getElementById('resultsArea').scrollIntoView({ behavior: 'smooth' });
            }
        }

        async function downloadAll() {
            if (generatedImages.length === 0) return;

            showLoader(true, "æ­£åœ¨æ‰“åŒ…ä¸‹è½½...");
            const zip = new JSZip();
            const folder = zip.folder("generated_ppts");

            generatedImages.forEach(img => {
                const base64Data = img.data.split(',')[1];
                folder.file(img.name, base64Data, { base64: true });
            });

            const content = await zip.generateAsync({ type: "blob" });
            
            const a = document.createElement("a");
            a.href = URL.createObjectURL(content);
            a.download = "PPT_Batch_Images.zip";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            showLoader(false);
        }

        function copyBlessingText() {
            const el = document.getElementById('blessingText');
            if(!el.value) return;
            
            el.select();
            el.setSelectionRange(0, 99999);
            
            navigator.clipboard.writeText(el.value).then(() => {
                alert("å¤åˆ¶æˆåŠŸï¼");
            }).catch(() => {
                document.execCommand('copy');
                alert("å¤åˆ¶æˆåŠŸï¼");
            });
        }
    </script>
</body>
</html>