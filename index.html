<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PPT 智能批量填字工具</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        body { font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif; background-color: #f3f4f6; }
        .loading-overlay {
            background: rgba(255, 255, 255, 0.9);
            z-index: 50;
        }
        canvas { border: 1px solid #e5e7eb; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1); }
        .scroll-hidden::-webkit-scrollbar { display: none; }
        .scroll-hidden { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden">

    <!-- Header -->
    <header class="bg-white shadow-sm z-10 p-4">
        <div class="max-w-7xl mx-auto flex justify-between items-center">
            <h1 class="text-xl font-bold text-gray-800 flex items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-blue-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 12l3-3 3 3 4-4M8 21l4-4 4 4M3 4h18M4 4h16v12a1 1 0 01-1 1H5a1 1 0 01-1-1V4z" />
                </svg>
                PPT 智能批量填字工具
            </h1>
            <button onclick="resetApp()" class="text-sm text-red-500 hover:text-red-700 underline">清除所有缓存重置</button>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-1 flex overflow-hidden">
        
        <!-- Left Sidebar: Controls -->
        <div class="w-1/3 min-w-[320px] bg-white border-r border-gray-200 flex flex-col h-full overflow-y-auto p-6 gap-6 shadow-lg z-10">
            
            <!-- Step 1: PPT Template -->
            <div class="space-y-3">
                <div class="flex items-center justify-between">
                    <h2 class="text-lg font-semibold text-gray-700">1. PPT 模板</h2>
                    <span id="pptStatus" class="text-xs px-2 py-1 rounded bg-gray-100 text-gray-500">未就绪</span>
                </div>
                
                <div id="pptUploadArea" class="border-2 border-dashed border-blue-200 rounded-lg p-6 text-center hover:bg-blue-50 transition cursor-pointer relative">
                    <input type="file" id="pptInput" accept=".pptx" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer">
                    <div class="text-blue-500 mb-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                        </svg>
                    </div>
                    <p class="text-sm text-gray-600">点击上传 .pptx 文件</p>
                    <p class="text-xs text-gray-400 mt-1">需包含“营服名称”文本框 (首页)</p>
                </div>
                
                <!-- Parsed Info Display -->
                <div id="pptInfo" class="hidden text-sm bg-green-50 p-3 rounded border border-green-100 text-green-800">
                    <p>✅ 模板已加载 (已缓存)</p>
                    <p class="text-xs mt-1 opacity-75">检测到坐标: <span id="coordInfo">--</span></p>
                </div>
            </div>

            <!-- Step 2: OCR Image -->
            <div class="space-y-3">
                <h2 class="text-lg font-semibold text-gray-700">2. 识别文字图片</h2>
                <div class="border-2 border-dashed border-indigo-200 rounded-lg p-6 text-center hover:bg-indigo-50 transition cursor-pointer relative">
                    <input type="file" id="ocrInput" accept="image/*" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer">
                    <div class="text-indigo-500 mb-2">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 mx-auto" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z" />
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 13a3 3 0 11-6 0 3 3 0 016 0z" />
                        </svg>
                    </div>
                    <p class="text-sm text-gray-600">上传文字列表图片</p>
                </div>
                
                <!-- OCR Result Text Area -->
                <div>
                    <div class="flex justify-between items-center mb-1">
                        <label class="text-xs text-gray-500">识别结果 (已自动去空格并添加“营服”):</label>
                        <span id="lineCount" class="text-xs text-blue-600 font-bold">0 行</span>
                    </div>
                    <textarea id="textList" class="w-full h-32 p-2 border border-gray-300 rounded text-sm focus:ring-2 focus:ring-blue-500 focus:outline-none" placeholder="识别后的文字将显示在这里..."></textarea>
                </div>
            </div>

            <!-- Step 3: Action -->
            <button id="generateBtn" disabled class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 rounded-lg shadow transition disabled:opacity-50 disabled:cursor-not-allowed">
                开始批量生成高清图片 & 祝福语
            </button>
        </div>

        <!-- Right Side: Preview & Results -->
        <div class="flex-1 bg-gray-50 p-8 overflow-y-auto flex flex-col items-center">
            
            <!-- Canvas Container (Hidden or used for processing) -->
            <div class="mb-6 relative">
                <h3 class="text-center text-gray-500 mb-2 text-sm uppercase tracking-wide">预览窗口 (基于第一行文字)</h3>
                <div class="canvas-container shadow-2xl border-4 border-white rounded-lg overflow-hidden origin-top-left transition-transform duration-200">
                    <canvas id="previewCanvas"></canvas>
                </div>
            </div>

            <!-- Results Grid: Images -->
            <div id="resultsArea" class="w-full max-w-4xl hidden mb-8">
                <div class="flex justify-between items-end border-b pb-2 mb-4">
                    <h3 class="text-lg font-bold text-gray-800">生成结果 (高清图片)</h3>
                    <button onclick="downloadAll()" class="text-sm bg-green-600 text-white px-3 py-1 rounded hover:bg-green-700">下载全部 (ZIP)</button>
                </div>
                <div id="gallery" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                    <!-- Images will be injected here -->
                </div>
            </div>

            <!-- Results: Blessing Text -->
            <div id="textResultArea" class="w-full max-w-4xl hidden pb-10">
                <div class="flex justify-between items-end border-b pb-2 mb-4">
                    <h3 class="text-lg font-bold text-gray-800">生成结果 (祝福语)</h3>
                    <button onclick="copyBlessingText()" class="text-sm bg-indigo-600 text-white px-3 py-1 rounded hover:bg-indigo-700 flex items-center gap-1">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 5H6a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2v-1M8 5a2 2 0 002 2h2a2 2 0 002-2M8 5a2 2 0 012-2h2a2 2 0 012 2m0 0h2a2 2 0 012 2v3m2 4H10m0 0l3-3m-3 3l3 3" />
                        </svg>
                        复制全部
                    </button>
                </div>
                <textarea id="blessingText" class="w-full h-48 p-4 border border-gray-300 rounded-lg bg-white text-gray-700 focus:outline-none focus:ring-2 focus:ring-indigo-200" readonly placeholder="点击生成后，这里将显示祝福语..."></textarea>
                <p class="text-xs text-gray-400 mt-2 text-right">已自动填充：恭喜XXX营服当日高套封闭[庆祝][庆祝][庆祝]</p>
            </div>
        </div>
    </main>

    <!-- Global Loader -->
    <div id="loader" class="fixed inset-0 loading-overlay flex flex-col items-center justify-center hidden">
        <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mb-4"></div>
        <p id="loaderText" class="text-gray-700 font-medium">正在处理...</p>
    </div>

    <!-- Scripts loaded at the end of body to ensure DOM is ready and parsing isn't blocked -->
    <!-- JSZip for parsing PPTX -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <!-- Tesseract.js for OCR -->
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <!-- Fabric.js for Canvas Manipulation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <!-- LocalForage for IndexedDB storage -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/localforage/1.10.0/localforage.min.js"></script>

    <script>
        // --- Constants & State ---
        const TARGET_TEXT = "营服名称";
        const CM_TO_PT = 28.346;
        const EMU_TO_PX = 96 / 914400; // 96 DPI / EMU per inch
        
        let fabricCanvas = null;
        let pptData = {
            bgImage: null, // Base64 string
            width: 1280,
            height: 720,
            textBox: null // { x, y, width, height, fontSize, fontFamily, color }
        };
        let generatedImages = []; // Stores { name: string, dataUrl: string }

        // --- Initialization ---
        window.onload = async () => {
            if (typeof fabric === 'undefined') {
                alert("Fabric.js 资源加载失败。请检查网络连接或刷新页面。");
                console.error("Fabric.js is not defined.");
                return;
            }
            if (typeof JSZip === 'undefined') {
                 console.error("JSZip is not defined.");
                 return;
            }
            
            initCanvas();
            await checkStoredPPT();
            setupEventListeners();
        };

        function initCanvas() {
            try {
                fabricCanvas = new fabric.Canvas('previewCanvas', {
                    enableRetinaScaling: true // Enable retina scaling for better display on high DPI screens
                });
                fabricCanvas.setWidth(640); // Initial placeholder
                fabricCanvas.setHeight(360);
                fabricCanvas.selection = false;
            } catch (error) {
                console.error("Canvas Initialization Error:", error);
                alert("Canvas 初始化失败，请刷新重试。");
            }
        }

        function showLoader(show, text = "处理中...") {
            const el = document.getElementById('loader');
            const txt = document.getElementById('loaderText');
            if (show) {
                txt.innerText = text;
                el.classList.remove('hidden');
            } else {
                el.classList.add('hidden');
            }
        }

        // --- Storage Logic ---
        async function checkStoredPPT() {
            try {
                const stored = await localforage.getItem('pptTemplateData');
                if (stored) {
                    pptData = stored;
                    updatePPTStatus(true, "从缓存加载");
                    renderPreview(TARGET_TEXT); // Render placeholder
                }
            } catch (e) {
                console.error("Storage error", e);
            }
        }

        async function savePPTData() {
            await localforage.setItem('pptTemplateData', pptData);
        }

        async function resetApp() {
            if(confirm("确定要清除存储的PPT模板吗？")){
                await localforage.clear();
                location.reload();
            }
        }

        // --- Event Listeners ---
        function setupEventListeners() {
            document.getElementById('pptInput').addEventListener('change', handlePPTUpload);
            document.getElementById('ocrInput').addEventListener('change', handleOCRUpload);
            document.getElementById('textList').addEventListener('input', updateLineCount);
            document.getElementById('generateBtn').addEventListener('click', startBatchGeneration);
        }

        function updatePPTStatus(isReady, msg) {
            const statusEl = document.getElementById('pptStatus');
            const infoEl = document.getElementById('pptInfo');
            const coordEl = document.getElementById('coordInfo');
            const btn = document.getElementById('generateBtn');

            if (isReady) {
                statusEl.innerText = "已就绪";
                statusEl.className = "text-xs px-2 py-1 rounded bg-green-100 text-green-700";
                infoEl.classList.remove('hidden');
                document.getElementById('pptUploadArea').classList.add('hidden');
                
                if (pptData.textBox) {
                    coordEl.innerText = `X: ${Math.round(pptData.textBox.x)}, Y: ${Math.round(pptData.textBox.y)}`;
                    btn.disabled = false;
                }
            } else {
                statusEl.innerText = msg || "错误";
                statusEl.className = "text-xs px-2 py-1 rounded bg-red-100 text-red-700";
            }
        }

        // --- PPT Parsing Logic (The Core) ---
        async function handlePPTUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            showLoader(true, "正在解析 PPT 文件...");

            try {
                const zip = await JSZip.loadAsync(file);
                
                // 1. Parse Slide XML
                let slideXmlStr = "";
                try {
                    slideXmlStr = await zip.file("ppt/slides/slide1.xml").async("string");
                } catch(e) {
                     throw new Error("无法读取幻灯片数据 (ppt/slides/slide1.xml)，请确认这是一个有效的 PPTX 文件。");
                }

                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(slideXmlStr, "text/xml");
                
                // --- Robust Text Finding ---
                const allElements = xmlDoc.getElementsByTagName("*");
                let targetShape = null;
                let debugFoundTexts = [];

                for (let i = 0; i < allElements.length; i++) {
                    const el = allElements[i];
                    
                    if (el.localName === "p" && (el.prefix === "a" || el.namespaceURI?.includes("drawingml"))) {
                        
                        const runTexts = [];
                        const textNodes = el.getElementsByTagName("*");
                        for(let k=0; k<textNodes.length; k++) {
                            if(textNodes[k].localName === "t") {
                                runTexts.push(textNodes[k].textContent);
                            }
                        }
                        
                        const fullText = runTexts.length > 0 ? runTexts.join("") : el.textContent;
                        const normalizedText = fullText.replace(/\s+/g, "");
                        
                        if (normalizedText && debugFoundTexts.length < 10) {
                            debugFoundTexts.push(normalizedText);
                        }

                        if (normalizedText.includes(TARGET_TEXT)) {
                            let node = el;
                            while (node && node.parentNode) {
                                if (node.localName === "sp" && (node.prefix === "p" || node.namespaceURI?.includes("presentationml"))) {
                                    targetShape = node;
                                    break;
                                }
                                node = node.parentNode;
                            }
                            if (targetShape) break;
                        }
                    }
                }

                if (!targetShape) {
                     console.warn("PPT Parse Debug: Found texts in slide 1:", debugFoundTexts);
                     throw new Error(`在第一页未找到“${TARGET_TEXT}”。\n已识别到的部分文字: ${debugFoundTexts.join(", ")}。\n请确保PPT第一页包含该文字文本框。`);
                }

                // Extract Geometry
                const getChild = (parent, localName) => {
                    if(!parent) return null;
                    for(let i=0; i<parent.children.length; i++) {
                        if(parent.children[i].localName === localName) return parent.children[i];
                    }
                    return null;
                };

                const spPr = getChild(targetShape, "spPr");
                const xfrm = getChild(spPr, "xfrm");
                const off = getChild(xfrm, "off");
                const ext = getChild(xfrm, "ext");

                if (!off || !ext) {
                    throw new Error("找到文本框但无法读取坐标信息 (xfrm/off/ext缺失)。");
                }

                const emuX = parseInt(off.getAttribute("x"));
                const emuY = parseInt(off.getAttribute("y"));
                const emuW = parseInt(ext.getAttribute("cx"));
                const emuH = parseInt(ext.getAttribute("cy"));

                // Extract Slide Dimensions
                const presentationXml = await zip.file("ppt/presentation.xml").async("string");
                const presDoc = parser.parseFromString(presentationXml, "text/xml");
                const sldSzTags = presDoc.getElementsByTagName("*");
                let sldSz = null;
                for(let i=0; i<sldSzTags.length; i++){
                    if(sldSzTags[i].localName === "sldSz") {
                        sldSz = sldSzTags[i];
                        break;
                    }
                }

                const slideWidthEmu = parseInt(sldSz.getAttribute("cx"));
                const slideHeightEmu = parseInt(sldSz.getAttribute("cy"));

                // Calculate Pixels
                const scaleFactor = 96 / 914400; // EMU to Pixels
                const canvasW = slideWidthEmu * scaleFactor;
                const canvasH = slideHeightEmu * scaleFactor;

                // Extract Font Style
                let fontSize = 18;
                let color = "#000000";
                
                try {
                    const textBody = getChild(targetShape, "txBody");
                    const p = getChild(textBody, "p");
                    const runs = p.getElementsByTagName("*");
                    for(let i=0; i<runs.length; i++) {
                        if(runs[i].localName === "rPr") {
                            const sz = runs[i].getAttribute("sz");
                            if(sz) fontSize = parseInt(sz) / 100;
                            
                            const solidFill = getChild(runs[i], "solidFill");
                            if(solidFill) {
                                const srgbClr = getChild(solidFill, "srgbClr");
                                if(srgbClr) color = "#" + srgbClr.getAttribute("val");
                            }
                            if(sz) break; 
                        }
                    }
                } catch(err) { console.log("Font style extraction info:", err); }

                // 2. Extract Background Image
                let bgBase64 = null;
                const mediaFolder = zip.folder("ppt/media");
                let maxUserInfo = { name: "", size: 0 };
                
                if (mediaFolder) {
                    mediaFolder.forEach((relativePath, file) => {
                        if (relativePath.match(/\.(jpeg|jpg|png)$/i)) {
                            if (file._data.uncompressedSize > maxUserInfo.size) {
                                maxUserInfo = { name: relativePath, size: file._data.uncompressedSize };
                            }
                        }
                    });

                    if (maxUserInfo.name) {
                        bgBase64 = await mediaFolder.file(maxUserInfo.name).async("base64");
                        const ext = maxUserInfo.name.split('.').pop();
                        bgBase64 = `data:image/${ext};base64,${bgBase64}`;
                    }
                }

                if (!bgBase64) {
                     try {
                        const thumb = await zip.file("docProps/thumbnail.jpeg").async("base64");
                        bgBase64 = "data:image/jpeg;base64," + thumb;
                     } catch(e) {
                         throw new Error("无法提取PPT背景图。请确保PPT包含背景图片。");
                     }
                }

                // Store Data
                pptData = {
                    width: canvasW,
                    height: canvasH,
                    bgImage: bgBase64,
                    textBox: {
                        x: emuX * scaleFactor,
                        y: emuY * scaleFactor,
                        w: emuW * scaleFactor,
                        h: emuH * scaleFactor,
                        fontSize: fontSize * 1.33, // Convert pt to px approx
                        color: color
                    }
                };

                await savePPTData();
                updatePPTStatus(true);
                renderPreview(TARGET_TEXT);

            } catch (err) {
                console.error(err);
                alert("PPT解析失败:\n" + err.message);
                updatePPTStatus(false, "解析失败");
            } finally {
                showLoader(false);
            }
        }

        // --- Rendering Logic ---
        function renderPreview(text) {
            if (!pptData.bgImage) return;

            fabricCanvas.setWidth(pptData.width);
            fabricCanvas.setHeight(pptData.height);
            
            // Set Background
            fabric.Image.fromURL(pptData.bgImage, (img) => {
                img.scaleToWidth(pptData.width);
                img.scaleToHeight(pptData.height);
                fabricCanvas.setBackgroundImage(img, fabricCanvas.renderAll.bind(fabricCanvas));
                
                // Clear existing
                fabricCanvas.clear();
                fabricCanvas.setBackgroundImage(img, fabricCanvas.renderAll.bind(fabricCanvas));

                // Add Text
                const tb = pptData.textBox;
                
                const textObj = new fabric.Textbox(text, {
                    left: tb.x,
                    top: tb.y,
                    width: tb.w,
                    height: tb.h, 
                    fontSize: tb.fontSize,
                    fill: tb.color,
                    fontFamily: 'SimHei, STHeiti, sans-serif',
                    textAlign: 'center',
                    originX: 'left',
                    originY: 'top',
                    editable: false
                });
                
                fabricCanvas.add(textObj);
                fabricCanvas.renderAll();
                
                // Fit canvas to screen logic
                const containerEl = document.querySelector('.canvas-container');
                if (containerEl && containerEl.parentElement) {
                    const containerW = containerEl.parentElement.clientWidth;
                    const scale = containerW / pptData.width;
                    if(scale < 1) {
                        containerEl.style.transform = `scale(${scale})`;
                        containerEl.parentElement.style.height = (pptData.height * scale) + 'px';
                    } else {
                        containerEl.style.transform = `scale(1)`;
                        containerEl.parentElement.style.height = 'auto';
                    }
                }
            });
        }

        // --- OCR Logic ---
        async function handleOCRUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            showLoader(true, "正在识别图片中的文字 (OCR)...");

            try {
                const worker = await Tesseract.createWorker('chi_sim'); // Simplified Chinese
                
                const ret = await worker.recognize(file);
                const text = ret.data.text;
                
                // Clean Text: Remove whitespace and append "营服"
                const lines = text.split('\n')
                                  .map(l => l.replace(/\s+/g, '').trim()) // Remove ALL spaces
                                  .filter(l => l.length > 0)
                                  .map(l => l + "营服"); // Append suffix
                
                document.getElementById('textList').value = lines.join('\n');
                updateLineCount();
                
                await worker.terminate();

                if (lines.length > 0) {
                    renderPreview(lines[0]);
                }

            } catch (err) {
                alert("OCR 识别失败: " + err.message);
            } finally {
                showLoader(false);
            }
        }

        function updateLineCount() {
            const txt = document.getElementById('textList').value;
            const count = txt.split('\n').filter(l => l.trim()).length;
            document.getElementById('lineCount').innerText = `${count} 行`;
            
            const btn = document.getElementById('generateBtn');
            btn.disabled = count === 0 || !pptData.bgImage;
        }

        // --- Batch Generation ---
        async function startBatchGeneration() {
            const txt = document.getElementById('textList').value;
            const lines = txt.split('\n').filter(l => l.trim());
            
            if (lines.length === 0) return;
            
            showLoader(true, "正在批量生成高清图片...");
            generatedImages = [];
            const gallery = document.getElementById('gallery');
            gallery.innerHTML = '';
            document.getElementById('resultsArea').classList.remove('hidden');
            
            // Show the text result area
            const textResultArea = document.getElementById('textResultArea');
            textResultArea.classList.remove('hidden');
            const blessingTextEl = document.getElementById('blessingText');

            // Generate Blessing Text Lines
            // Format: 恭喜XXX营服当日高套封闭[庆祝][庆祝][庆祝]
            const blessingLines = lines.map(line => `恭喜${line}当日高套封闭[庆祝][庆祝][庆祝]`);
            blessingTextEl.value = blessingLines.join('\n');

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                const objs = fabricCanvas.getObjects();
                if (objs.length > 0 && objs[0].type === 'textbox') {
                    objs[0].set('text', line);
                    fabricCanvas.renderAll();
                } else {
                    renderPreview(line);
                }

                await new Promise(r => setTimeout(r, 100));

                // Export at 3x resolution for clarity
                const dataUrl = fabricCanvas.toDataURL({
                    format: 'png',
                    quality: 1,
                    multiplier: 3 // High resolution export
                });

                generatedImages.push({ name: `${line}.png`, data: dataUrl });

                const imgCard = document.createElement('div');
                imgCard.className = "bg-white p-2 rounded shadow border border-gray-200";
                imgCard.innerHTML = `
                    <img src="${dataUrl}" class="w-full h-auto mb-2 rounded border">
                    <p class="text-xs text-center text-gray-600 truncate font-bold">${line}</p>
                `;
                gallery.appendChild(imgCard);
            }

            showLoader(false);
        }

        async function downloadAll() {
            if (generatedImages.length === 0) return;

            showLoader(true, "正在打包下载...");
            const zip = new JSZip();
            const folder = zip.folder("generated_ppts");

            generatedImages.forEach(img => {
                const base64Data = img.data.split(',')[1];
                folder.file(img.name, base64Data, { base64: true });
            });

            const content = await zip.generateAsync({ type: "blob" });
            
            const a = document.createElement("a");
            a.href = URL.createObjectURL(content);
            a.download = "PPT_Batch_Images.zip";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            showLoader(false);
        }

        // --- Blessing Text Logic ---
        function copyBlessingText() {
            const el = document.getElementById('blessingText');
            if(!el.value) return;
            
            el.select();
            el.setSelectionRange(0, 99999); // For mobile
            
            try {
                // Modern API if possible, fallback to execCommand
                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard.writeText(el.value).then(() => {
                        // Using a simple indicator instead of alert for better UX
                        const btn = document.querySelector('button[onclick="copyBlessingText()"]');
                        const originalText = btn.innerHTML;
                        btn.innerText = "已复制!";
                        setTimeout(() => btn.innerHTML = originalText, 2000);
                    });
                } else {
                    document.execCommand('copy');
                    const btn = document.querySelector('button[onclick="copyBlessingText()"]');
                    const originalText = btn.innerHTML;
                    btn.innerText = "已复制!";
                    setTimeout(() => btn.innerHTML = originalText, 2000);
                }
            } catch (err) {
                alert("复制失败，请手动复制。");
            }
        }

    </script>
</body>
</html>